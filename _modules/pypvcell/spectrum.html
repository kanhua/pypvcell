<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pypvcell.spectrum &#8212; pypvcell 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pypvcell 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pypvcell.spectrum</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Introduction</span>
<span class="sd">-------------</span>

<span class="sd">Spectrum class is designed to simplify the unit conversions, interpolation and arithmetic operations of spectrum data in the form of ``y(x)`` or ``y(x)dx``.</span>
<span class="sd">When modeling solar cells, we often have to deal with spectrum with different units. For example, the ``x`` of your EQE is in photon energy (eV), but the ``x`` of the illumination spectrum is in wavelength (nm), and you want to multiply them to get Jsc. You then have to convert the ``x`` of EQE into wavelength, reverse the sequence of both ``x`` and ``y``, interpolate either the EQE or the illumination spectrum, convert ``y`` of the illumination spectrum into photon flux, multiply the data and finally run numerical integration to get Jsc. These processes can cause some headache and very error prone. ``Spectrum`` class aims to make these calculations robust and easy.</span>

<span class="sd">Spectrum class bundles the data of ``x``, ``y`` and their associated units together into an object. This design may look clumsy at first sight, but this helps reduce many potential errors that could happen when handling the unit conversions of the data. The reason is that the value of ``y`` is often coupled with the unit of ``x``. For example, converting the ``y`` data from energy flux into photon flux requires the values of ``x``.</span>

<span class="sd">Design of ``Spectrum`` class</span>
<span class="sd">-----------------------------</span>

<span class="sd">An instance of ``Spectrum`` class bundles the following key properties of a spectrum y(x):</span>

<span class="sd">- ``x_data``: the values of x</span>
<span class="sd">- ``y_data``: the values of y</span>
<span class="sd">- ``x_unit``: the unit of x (strings), e.g. &#39;eV&#39;, &#39;nm&#39;, &#39;J&#39; and so on.</span>
<span class="sd">- ``y_area_unit`` (optional): use this if the spectrum is something per area, such as sun irradiance (W/m^2), e.g., &#39;m 2&#39;)</span>
<span class="sd">- ``is_spec_density``: a boolean value to specify whether the spectrum is y(x)dx. In other words, this should be set to ``True`` if the integration of y(x)dx is a physical quantity. For example, this should be set to ``True`` when dealing with the sun irradiance spectrum because the integration of the sun irradiance spectrum gives the total illumination power. On the other hand, this should be set to ``False`` for spectrum like quantum efficiency or absorption spectrum.</span>
<span class="sd">- ``is_photon_flux``: This boolean values specifies whether the spectrum is photon flux.</span>


<span class="sd">Access the values in ``Spectrum``</span>
<span class="sd">-----------------------------------</span>

<span class="sd">One can use ``get_spectrum()`` or ``get_interp_spectrum()`` to accessing the values of x and y in a spectrum. When retrieving the values of spectrum data, the user has to specify the unit for x. Both of these functions will handle the unit conversion and rearrange the order of x and y (say, when converting nm to eV).</span>

<span class="sd">``get_spectrum()`` returns the 2xL numpy array of the x and y data.</span>

<span class="sd">``get_interp_spectrum()`` returns the 2xL numpy array of interpolated x and y data from given x.</span>


<span class="sd">Arithmetic operations</span>
<span class="sd">-----------------------</span>

<span class="sd">Spectrum class supports arithmetic operations between different spectrum, for example: ::</span>

<span class="sd">    # Multiplication of two spectrum</span>
<span class="sd">    s3=s1*s2</span>

<span class="sd">If s1 and s2 have different x, the function will interpolate s2 based on the values of x in s1.</span>
<span class="sd">After that, it does the multiplication of y in s1 and s2.</span>

<span class="sd">Spectrum calss also supports arithmetic operations with single float number, for example: ::</span>

<span class="sd">    # Multiply a spectrum by a single number</span>
<span class="sd">    s2=s1*0.5</span>

<span class="sd">or ::</span>

<span class="sd">    s2=0.5*s1</span>

<span class="sd">This operation multiply all the y values in s1 by 0.5 and return the result to s2.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">from</span> <span class="nn">pint</span> <span class="k">import</span> <span class="n">UnitRegistry</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="n">ug</span> <span class="o">=</span> <span class="n">UnitRegistry</span><span class="p">()</span>

<span class="c1"># for unit comparision. Declared here for perfomance purpose.</span>
<span class="n">_lu</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dimensionality</span>  <span class="c1"># length</span>
<span class="n">_eu</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dimensionality</span>  <span class="c1"># energy</span>
<span class="n">_ilu</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="s1">&#39;1/m&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dimensionality</span>  <span class="c1"># 1/length</span>
<span class="n">_itu</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="s1">&#39;1/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dimensionality</span>  <span class="c1"># 1/s, frequency</span>

<span class="c1"># define constants for unit conversions</span>
<span class="n">_h_unit</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">(</span><span class="s1">&#39;J s&#39;</span><span class="p">)</span>
<span class="n">_c_unit</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">(</span><span class="s1">&#39;m/s&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_energy_to_length</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">e_unit</span><span class="p">,</span> <span class="n">l_unit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert wavelength to photon energy. The conversion is bi-directional. As a result, instead of using source and destination as input parameters, it uses &quot;energy unit&quot; and &quot;length unit&quot; as inputs.</span>

<span class="sd">    :param value: The unit to be converted</span>
<span class="sd">    :param e_unit: the unit of energy, such as &#39;J&#39;, &#39;eV&#39;</span>
<span class="sd">    :type e_unit: str</span>
<span class="sd">    :param l_unit: the unit of wavelength, such as &#39;m&#39;, &#39;nm&#39;</span>
<span class="sd">    :type l_unit: str</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">_energy_to_length_factor</span><span class="p">(</span><span class="n">e_unit</span><span class="p">,</span> <span class="n">l_unit</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">h</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_energy_to_length_factor</span><span class="p">(</span><span class="n">e_unit</span><span class="p">,</span> <span class="n">l_unit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the units of Planck&#39;s constant and speed of light</span>

<span class="sd">    :param e_unit:</span>
<span class="sd">    :type e_unit: str</span>
<span class="sd">    :param l_unit:</span>
<span class="sd">    :type l_unit: str</span>
<span class="sd">    :return: c,h</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">dest_h_u</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> s&#39;</span> <span class="o">%</span> <span class="n">e_unit</span><span class="p">)</span>
    <span class="n">dest_c_u</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/s&#39;</span> <span class="o">%</span> <span class="n">l_unit</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dest_h_u</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">!=</span> <span class="n">_h_unit</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;e_unit should be a valid energy unit&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dest_c_u</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">!=</span> <span class="n">_c_unit</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;l_unit should be a valid length unit&#39;</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">_h_unit</span><span class="p">,</span> <span class="n">dest_h_u</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">_c_unit</span><span class="p">,</span> <span class="n">dest_c_u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">_spec_density_conversion</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">e_unit</span><span class="p">,</span> <span class="n">l_unit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the units of spectral density.</span>

<span class="sd">    :param x: x_data</span>
<span class="sd">    :type x: np.ndarray</span>
<span class="sd">    :param y: y_data</span>
<span class="sd">    :type y: np.ndarray</span>
<span class="sd">    :param e_unit: the unit of energy, such as &#39;J&#39;, &#39;eV&#39;</span>
<span class="sd">    :type e_unit: str</span>
<span class="sd">    :param l_unit: the unit of wavelength, such as &#39;m&#39;, &#39;nm&#39;</span>
<span class="sd">    :type l_unit: str</span>
<span class="sd">    :return: x, y</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">_energy_to_length_factor</span><span class="p">(</span><span class="n">e_unit</span><span class="p">,</span> <span class="n">l_unit</span><span class="p">)</span>

    <span class="n">new_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">new_y</span>


<span class="k">def</span> <span class="nf">compare_wavelength_dimension</span><span class="p">(</span><span class="n">unit_1</span><span class="p">,</span> <span class="n">unit_2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether the unit_1 and unit_2 are valid units.</span>
<span class="sd">    It returns true when:</span>

<span class="sd">    unit_1==unit_2</span>
<span class="sd">    set(unit_1,unit_2)=set([length],[energy])</span>
<span class="sd">    set(unit_1,unit_2)=set([length],1/[length])</span>
<span class="sd">    set(unit_1,unit_2)=set([length],[frequency])</span>

<span class="sd">    :param unit_1: unit 1, e.g. &#39;m&#39;, &#39;J&#39;,etc.</span>
<span class="sd">    :type unit_1: str</span>
<span class="sd">    :param unit_2: unit 2, e.g. &#39;m&#39;, &#39;J&#39;,etc.</span>
<span class="sd">    :type unit_2: str</span>
<span class="sd">    :return: boolean value</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">un1</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">unit_1</span><span class="p">)</span><span class="o">.</span><span class="n">dimensionality</span>
    <span class="n">un2</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">unit_2</span><span class="p">)</span><span class="o">.</span><span class="n">dimensionality</span>

    <span class="k">if</span> <span class="n">un1</span> <span class="o">==</span> <span class="n">un2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">set</span><span class="p">([</span><span class="n">un1</span><span class="p">,</span> <span class="n">un2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="n">_lu</span><span class="p">,</span> <span class="n">_eu</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">set</span><span class="p">([</span><span class="n">un1</span><span class="p">,</span> <span class="n">un2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="n">_lu</span><span class="p">,</span> <span class="n">_ilu</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">set</span><span class="p">([</span><span class="n">un1</span><span class="p">,</span><span class="n">un2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="n">_lu</span><span class="p">,</span><span class="n">_itu</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="Spectrum"><a class="viewcode-back" href="../../spectrum_class.html#pypvcell.spectrum.Spectrum">[docs]</a><span class="k">class</span> <span class="nc">Spectrum</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class handles the operation of the spectrum y(x), including unit conversion and multiplication.</span>


<span class="sd">    It can handle unit conversions of different types of spectrum, including:</span>

<span class="sd">    - Standard spectrum. The unit of y is independent of x, e.g. quantum efficiency, absorption spectrum, etc.</span>
<span class="sd">    - Sepctral density. The unit of y is per [x-unit]. For example, the Black-body radiation spectrum is often in the unit of energy/nm/m^2</span>
<span class="sd">    - Photon flux: y is number of photons. When converting y into energy (J), it has to be multiplied by its photon energy.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spectrum.__init__"><a class="viewcode-back" href="../../spectrum_class.html#pypvcell.spectrum.Spectrum.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">x_unit</span><span class="p">,</span> <span class="n">y_unit</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">is_spec_density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_photon_flux</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the spectrum y(x)</span>

<span class="sd">        :param is_spec_density:</span>
<span class="sd">        :param x_data: x data of the spectrum (1d numpy array)</span>
<span class="sd">        :param y_data: y data of the spectrum (1d numpy array)</span>
<span class="sd">        :param x_unit: the unit of x (string), e.g. &#39;nm&#39;, &#39;eV&#39;</span>
<span class="sd">        :param y_unit: (string) If y is per area, put area unit here, e.g. &#39;m-2&#39; or &#39;cm-2&#39;.</span>
<span class="sd">                Put null string &#39;&#39; if y does not have area unit</span>
<span class="sd">        :param is_photon_flux: (boolean). True if y is number of photons.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: fix docstring&#39;s y unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_spectrum</span><span class="p">(</span><span class="n">x_data</span><span class="o">=</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="o">=</span><span class="n">y_data</span><span class="p">,</span> <span class="n">x_unit</span><span class="o">=</span><span class="n">x_unit</span><span class="p">,</span>
                          <span class="n">y_area_unit</span><span class="o">=</span><span class="n">y_unit</span><span class="p">,</span>
                          <span class="n">is_photon_flux</span><span class="o">=</span><span class="n">is_photon_flux</span><span class="p">,</span>
                          <span class="n">is_spec_density</span><span class="o">=</span><span class="n">is_spec_density</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.set_spectrum"><a class="viewcode-back" href="../../spectrum_class.html#pypvcell.spectrum.Spectrum.set_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">set_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">x_unit</span><span class="p">,</span> <span class="n">y_area_unit</span><span class="p">,</span> <span class="n">is_photon_flux</span><span class="p">,</span> <span class="n">is_spec_density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is essentially a constructor method that sets up the attributes of the object.</span>
<span class="sd">        It converts everything to standard MKS unit. x_data: &#39;m&#39;, y_data: &#39;[]/m^2-m&#39;</span>

<span class="sd">        :param x_data: x data of the spectrum (1d numpy array)</span>
<span class="sd">        :param y_data: y data of the spectrum (1d numpy array)</span>
<span class="sd">        :param x_unit: the unit of x (string), e.g. &#39;nm&#39;, &#39;eV&#39;</span>
<span class="sd">        :type x_unit: str</span>
<span class="sd">        :param y_area_unit: If y is per area, put area unit here, e.g. &#39;m**-2&#39; or &#39;cm**-2&#39;. Put null string &#39;&#39; if y does not have area unit</span>
<span class="sd">        :type y_area_unit: str</span>
<span class="sd">        :param is_photon_flux: True if y is number of photons.</span>
<span class="sd">        :type is_photon_flux: bool</span>
<span class="sd">        :param is_spec_density: True if y is spectral density.</span>
<span class="sd">        :type is_spec_density: bool</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_area_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">is_photon_flux</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">is_spec_density</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Convert everything to photon energy : [arb]/m^2-m</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_density</span> <span class="o">=</span> <span class="n">is_spec_density</span>

        <span class="k">if</span> <span class="n">y_area_unit</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">core_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_spectrum_unit</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">from_x_unit</span><span class="o">=</span><span class="n">x_unit</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span>
                                                                  <span class="n">from_y_area_unit</span><span class="o">=</span><span class="n">y_area_unit</span><span class="p">,</span> <span class="n">to_y_area_unit</span><span class="o">=</span><span class="s1">&#39;m**-2&#39;</span><span class="p">,</span>
                                                                  <span class="n">is_spec_density</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_spec_density</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_area_unit</span> <span class="o">=</span> <span class="s1">&#39;m**-2&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">core_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_spectrum_unit</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">from_x_unit</span><span class="o">=</span><span class="n">x_unit</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span>
                                                                  <span class="n">from_y_area_unit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">to_y_area_unit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                                                  <span class="n">is_spec_density</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_spec_density</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_area_unit</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># Convert photon flux to energy (J) representation</span>
        <span class="k">if</span> <span class="n">is_photon_flux</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">core_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_energy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.convert_spectrum_unit"><a class="viewcode-back" href="../../spectrum_class.html#pypvcell.spectrum.Spectrum.convert_spectrum_unit">[docs]</a>    <span class="k">def</span> <span class="nf">convert_spectrum_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">from_x_unit</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="p">,</span>
                              <span class="n">from_y_area_unit</span><span class="p">,</span> <span class="n">to_y_area_unit</span><span class="p">,</span>
                              <span class="n">is_spec_density</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A general method for converting the spectrum y(x) from one set of unit to another.</span>
<span class="sd">        Note that this only supports the conversion of x from:</span>
<span class="sd">        [length]&lt;-&gt;[frequency]</span>
<span class="sd">        [length]&lt;-&gt; 1/[length]</span>
<span class="sd">        [length]&lt;-&gt;[energy]</span>

<span class="sd">        This is because Spectrum class converts the units of x to [length] first when initilizing or new spectrum is set.</span>
<span class="sd">        Therefore this function only implments the bi-direction unit conversions that involves [length].</span>

<span class="sd">        :param x_data: data of x (numpy array)</span>
<span class="sd">        :param y_data: data of y (numpy array)</span>
<span class="sd">        :param from_x_unit: the unit of x_data</span>
<span class="sd">        :param to_x_unit: the unit of x_data to be converted to</span>
<span class="sd">        :param from_y_area_unit: the unit of area of y_data</span>
<span class="sd">        :param to_y_area_unit: the unit of area of y_data tobe converted to</span>
<span class="sd">        :param is_spec_density: True if the data is spectral density.</span>
<span class="sd">        :return: a tuple of 1-d array (new_x_data, new_y_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">from_x_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_x_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">from_y_area_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_y_area_unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">is_spec_density</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="n">src_x_u</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">from_x_unit</span><span class="p">)</span>
        <span class="n">des_x_u</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">to_x_unit</span><span class="p">)</span>

        <span class="n">src_x_udim</span> <span class="o">=</span> <span class="n">src_x_u</span><span class="o">.</span><span class="n">dimensionality</span>
        <span class="n">des_x_udim</span> <span class="o">=</span> <span class="n">des_x_u</span><span class="o">.</span><span class="n">dimensionality</span>

        <span class="n">au1</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">from_y_area_unit</span><span class="p">)</span>
        <span class="n">au2</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">to_y_area_unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x_data</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">y_data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The array size of x_data and y_data do not match.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">compare_wavelength_dimension</span><span class="p">(</span><span class="n">from_x_unit</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dimension of from_x_unit and to_x_unit do not match.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">au1</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">==</span> <span class="n">au2</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dimension of from y_area_unit and to_y_area_unit do not match.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_spec_density</span><span class="p">:</span>
            <span class="n">from_dx_unit</span> <span class="o">=</span> <span class="n">from_x_unit</span> <span class="o">+</span> <span class="s2">&quot;**-1&quot;</span>
            <span class="n">to_dx_unit</span> <span class="o">=</span> <span class="n">to_x_unit</span> <span class="o">+</span> <span class="s2">&quot;**-1&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">from_dx_unit</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">to_dx_unit</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">orig_y_div_unit</span> <span class="o">=</span> <span class="n">from_y_area_unit</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">from_dx_unit</span>
        <span class="n">new_orig_y_div_unit</span> <span class="o">=</span> <span class="n">to_y_area_unit</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">to_dx_unit</span>

        <span class="c1"># Simple case</span>
        <span class="k">if</span> <span class="n">src_x_udim</span> <span class="o">==</span> <span class="n">des_x_udim</span><span class="p">:</span>

            <span class="n">new_x_data</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">from_x_unit</span><span class="p">),</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">to_x_unit</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">is_spec_density</span><span class="p">:</span>
                <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">orig_y_div_unit</span><span class="p">),</span>
                                        <span class="n">ug</span><span class="o">.</span><span class="n">parse_units</span><span class="p">(</span><span class="n">new_orig_y_div_unit</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">from_y_area_unit</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">to_y_area_unit</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">au1</span><span class="p">,</span> <span class="n">au2</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">y_data</span>

        <span class="k">elif</span> <span class="n">src_x_udim</span> <span class="o">==</span> <span class="n">_lu</span> <span class="ow">and</span> <span class="n">des_x_udim</span> <span class="o">==</span> <span class="n">_eu</span><span class="p">:</span>

            <span class="n">new_x_data</span> <span class="o">=</span> <span class="n">_energy_to_length</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="p">,</span> <span class="n">from_x_unit</span><span class="p">)</span>

            <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">au1</span><span class="p">,</span> <span class="n">au2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_spec_density</span><span class="p">:</span>
                <span class="n">new_x_data</span><span class="p">,</span> <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">_spec_density_conversion</span><span class="p">(</span><span class="n">new_x_data</span><span class="p">,</span> <span class="n">new_y_data</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="p">,</span> <span class="n">from_x_unit</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">src_x_udim</span> <span class="o">==</span> <span class="n">_eu</span> <span class="ow">and</span> <span class="n">des_x_udim</span> <span class="o">==</span> <span class="n">_lu</span><span class="p">:</span>

            <span class="n">new_x_data</span> <span class="o">=</span> <span class="n">_energy_to_length</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">from_x_unit</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="p">)</span>

            <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">au1</span><span class="p">,</span> <span class="n">au2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_spec_density</span><span class="p">:</span>
                <span class="n">new_x_data</span><span class="p">,</span> <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">_spec_density_conversion</span><span class="p">(</span><span class="n">new_x_data</span><span class="p">,</span> <span class="n">new_y_data</span><span class="p">,</span> <span class="n">from_x_unit</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">set</span><span class="p">([</span><span class="n">src_x_udim</span><span class="p">,</span> <span class="n">des_x_udim</span><span class="p">])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="n">_lu</span><span class="p">,</span> <span class="n">_ilu</span><span class="p">]):</span>

            <span class="c1"># The conversion is bi-directional, we use nm -&gt; cm^-1 as the example for the following comments</span>

            <span class="n">x_data_q</span> <span class="o">=</span> <span class="n">x_data</span> <span class="o">*</span> <span class="n">src_x_u</span> <span class="c1"># attach the unit to the quantities</span>

            <span class="n">inv_scr_x_u</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">src_x_u</span> <span class="c1"># get the inverse unit of x for converting y, nm -&gt; nm-1</span>

            <span class="n">x_data_q</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x_data_q</span> <span class="c1"># Do the inverse of x data and its unit</span>

            <span class="n">new_x_data</span> <span class="o">=</span> <span class="n">x_data_q</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">des_x_u</span><span class="p">)</span><span class="o">.</span><span class="n">m</span> <span class="c1"># Do the unit conversion and retrieve the value</span>

            <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">au1</span><span class="p">,</span> <span class="n">au2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_spec_density</span><span class="p">:</span>

                <span class="c1"># Convert the values of y, for example, from  []/nm to []/cm, assuming that we are converting x from [nm] to [cm]</span>
                <span class="n">new_y_data</span><span class="o">=</span><span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">new_y_data</span><span class="p">,</span><span class="n">inv_scr_x_u</span><span class="p">,</span><span class="n">des_x_u</span><span class="p">)</span>

                <span class="c1"># Then run dk=d(lambda)/lambda^2</span>
                <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">new_y_data</span> <span class="o">/</span> <span class="n">new_x_data</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">elif</span> <span class="n">src_x_udim</span><span class="o">==</span><span class="n">_lu</span> <span class="ow">and</span> <span class="n">des_x_udim</span><span class="o">==</span><span class="n">_itu</span><span class="p">:</span>

            <span class="n">c</span><span class="o">=</span><span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;m/s&#39;</span><span class="p">,</span><span class="n">from_x_unit</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">to_x_unit</span><span class="p">)</span>

            <span class="n">new_x_data</span><span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">x_data</span>

            <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">au1</span><span class="p">,</span> <span class="n">au2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_spec_density</span><span class="p">:</span>

                <span class="n">new_y_data</span><span class="o">=</span><span class="n">new_y_data</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">new_x_data</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">elif</span> <span class="n">src_x_udim</span><span class="o">==</span><span class="n">_itu</span> <span class="ow">and</span> <span class="n">des_x_udim</span><span class="o">==</span><span class="n">_lu</span><span class="p">:</span>

            <span class="n">c</span><span class="o">=</span><span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;m/s&#39;</span><span class="p">,</span><span class="n">to_x_unit</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">from_x_unit</span><span class="p">)</span>

            <span class="n">new_x_data</span><span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">x_data</span>

            <span class="n">new_y_data</span> <span class="o">=</span> <span class="n">ug</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">au1</span><span class="p">,</span> <span class="n">au2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_spec_density</span><span class="p">:</span>

                <span class="n">new_y_data</span><span class="o">=</span><span class="n">new_y_data</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">new_x_data</span><span class="o">**</span><span class="mi">2</span>


        <span class="k">return</span> <span class="n">new_x_data</span><span class="p">,</span> <span class="n">new_y_data</span></div>

<div class="viewcode-block" id="Spectrum.get_spectrum"><a class="viewcode-back" href="../../spectrum_class.html#pypvcell.spectrum.Spectrum.get_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">get_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="p">,</span> <span class="n">to_y_area_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_photon_flux</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the values of the spectrum based on the given units of x and y.</span>

<span class="sd">        :param to_x_unit: the unit of x</span>
<span class="sd">        :param to_y_area_unit: the unit of area of y. Default is the y_area_unit of the object.</span>
<span class="sd">        :param to_photon_flux: True if converting y to photon flux.</span>
<span class="sd">        :return: a 2xL numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">to_y_area_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_y_area_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_area_unit</span>

        <span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_spectrum_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_y</span><span class="p">,</span>
                                                    <span class="n">from_x_unit</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="o">=</span><span class="n">to_x_unit</span><span class="p">,</span>
                                                    <span class="n">from_y_area_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y_area_unit</span><span class="p">,</span> <span class="n">to_y_area_unit</span><span class="o">=</span><span class="n">to_y_area_unit</span><span class="p">,</span>
                                                    <span class="n">is_spec_density</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_spec_density</span><span class="p">)</span>

        <span class="c1"># convert the spectrum to photon flux if necessary</span>
        <span class="k">if</span> <span class="n">to_photon_flux</span><span class="p">:</span>
            <span class="n">y_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_photon_flux</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_x</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>

        <span class="c1"># Sort the spectrum by wavelength</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">x_data</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">y_data</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">))</span></div>

<div class="viewcode-block" id="Spectrum.get_interp_spectrum"><a class="viewcode-back" href="../../spectrum_class.html#pypvcell.spectrum.Spectrum.get_interp_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">get_interp_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_x_data</span><span class="p">,</span> <span class="n">to_x_unit</span><span class="p">,</span> <span class="n">to_y_area_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_photon_flux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">interp_left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interp_right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get interpolated spectrum.</span>

<span class="sd">        :param to_x_data: (ndarray) x values to be interpolated</span>
<span class="sd">        :param to_x_unit: (string) unit of x of the output value</span>
<span class="sd">        :param to_y_area_unit: (string) unit of area of y of the output value.</span>
<span class="sd">        :param to_photon_flux: (bool) True if converting the value to photon flux as the output</span>
<span class="sd">        :param interp_left: value to return for x &lt; core_x[0], return core_x[0] if set to be None</span>
<span class="sd">        :param interp_right: value to return for x&gt; core_x[-1], return core_y[-1] if set to be None</span>
<span class="sd">        :return: a 2xL array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">orig_spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spectrum</span><span class="p">(</span><span class="n">to_x_unit</span><span class="p">,</span> <span class="n">to_y_area_unit</span><span class="p">,</span> <span class="n">to_photon_flux</span><span class="o">=</span><span class="n">to_photon_flux</span><span class="p">)</span>

        <span class="n">output_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">to_x_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">output_spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">to_x_data</span>
        <span class="n">output_spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">to_x_data</span><span class="p">,</span> <span class="n">orig_spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                                          <span class="n">orig_spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">left</span><span class="o">=</span><span class="n">interp_left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">interp_right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output_spectrum</span></div>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse</span><span class="p">()</span><span class="o">.</span><span class="n">_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_area_unit</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: y data is not dimensionless!&quot;</span><span class="p">)</span>

        <span class="n">newobj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">newobj</span><span class="o">.</span><span class="n">core_y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">newobj</span><span class="o">.</span><span class="n">core_y</span>

        <span class="k">return</span> <span class="n">newobj</span>

    <span class="k">def</span> <span class="nf">_arith_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do the arithmetic operations</span>

<span class="sd">        :param s2: an instance of Spectrum</span>
<span class="sd">        :type s2: Spectrum,float</span>
<span class="sd">        :param op: numpy ufunc, such as np.add, np.substract, np.multiply, np.divide</span>
<span class="sd">        :return: the new Spectrum instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">Spectrum</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec_arith_op</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">newobj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">newobj</span><span class="o">.</span><span class="n">core_y</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">newobj</span><span class="o">.</span><span class="n">core_y</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">newobj</span><span class="o">.</span><span class="n">core_x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">newobj</span><span class="o">.</span><span class="n">core_y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The multipler should either be a scalar or a Spectrum calss object&quot;</span>
                                    <span class="s2">&quot;, or an ndarray that matches the length of the spectrum&quot;</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">newobj</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">err</span><span class="p">(</span>
                    <span class="s2">&quot;Runtime Error: The multipler should either be a scalar or a Spectrum class object when doing Spectrum multiplication&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_spec_arith_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do the arithmetic operations of two Spectrum instances</span>

<span class="sd">        :param s2: an instance of Spectrum</span>
<span class="sd">        :type s2: Spectrum</span>
<span class="sd">        :param op: numpy ufunc, such as np.add, np.substract, np.multiply, np.divide</span>
<span class="sd">        :param inplace: True if the results overwrites the instance itself.</span>
<span class="sd">        :type inplace: bool</span>
<span class="sd">        :return: the new spectrum opject. Return None if inplace is set True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">Spectrum</span><span class="p">)</span>

        <span class="n">new_spec</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">get_interp_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_x</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span>

        <span class="n">new_core_spec</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_y</span><span class="p">,</span> <span class="n">new_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">core_y</span> <span class="o">=</span> <span class="n">new_core_spec</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newobj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">newobj</span><span class="o">.</span><span class="n">core_y</span> <span class="o">=</span> <span class="n">new_core_spec</span>
            <span class="k">return</span> <span class="n">newobj</span>

    <span class="k">def</span> <span class="nf">_as_photon_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">energy_flux</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">energy_flux</span> <span class="o">/</span> <span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">h</span> <span class="o">*</span> <span class="n">sc</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">wavelength</span>

    <span class="k">def</span> <span class="nf">_as_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">photon_flux</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">photon_flux</span> <span class="o">*</span> <span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">h</span> <span class="o">*</span> <span class="n">sc</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">wavelength</span></div>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Kan-Hua Lee.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>