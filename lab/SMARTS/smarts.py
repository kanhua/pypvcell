import numpy
# from numpy import *
# from datetime import datetime
# from solcore3.units_system import UnitsSystem
# from numpy import flipud as reverse

import os, subprocess
import time
import pandas as pd
import copy
import re
from pypvcell.spectrum import Spectrum


def spec_data_to_spec_class(data):
    x_data = data['WVLGTH'].values

    y_col = {'ET_SPCTRUM': 'ext',
             'BEAM_NORMAL': 'direct',
             'BEAM_NORM+': 'direct_exp',
             'GLOB_HORIZ': 'ghi',
             'GLOBL_TILT': 'ghi_tilt'}

    output_data = {}

    for y_col_name in y_col.keys():
        y_data = data[y_col_name].values

        spec = Spectrum(x_data, y_data, x_unit='nm',
                        y_unit='m**-2', is_spec_density=True)

        output_data[y_col[y_col_name]] = spec

    return output_data


def get_astm_airmass(airmass):
    spec_param = copy.copy(astmg_173_03_m)
    spec_param['AMASS'] = airmass

    file = build_smarts_file(**spec_param)

    data = send_to_smarts(file)

    return data


def get_clear_sky(time, extend_dict={},extend_df=None):
    dtidx = pd.DatetimeIndex(time)

    year_s = dtidx.year
    month_s = dtidx.month
    day_s = dtidx.day
    hour_s = dtidx.hour
    min_s = dtidx.minute

    alldf = []
    all_out_data_df = []

    astmg_173_03_m.update(extend_dict)

    astmg_173_03_m['IMASS'] = 3
    astmg_173_03_m['LATIT'] = 35.1814
    astmg_173_03_m['LONGIT'] = 136.9064
    astmg_173_03_m['ZONE'] = 9

    for i in range(len(dtidx)):
        astmg_173_03_m['YEAR'] = year_s[i]
        astmg_173_03_m['MONTH'] = month_s[i]
        astmg_173_03_m['DAY'] = day_s[i]
        astmg_173_03_m['HOUR'] = hour_s[i] + min_s[i] / 60

        if extend_df is not None:
            for c in extend_df.columns:
                astmg_173_03_m[c]=extend_df[c][i]

        file = build_smarts_file(**astmg_173_03_m)

        data, out_data_dict = send_to_smarts(file)

        if data is not None:
            data["time"] = dtidx[i]

            data.set_index(['time'],inplace=True)

            alldf.append(data)

        out_data_df = pd.DataFrame.from_dict(out_data_dict)
        out_data_df["time"] = dtidx[i]
        out_data_df.set_index(["time"], inplace=True)
        all_out_data_df.append(out_data_df)

    alldata = pd.concat(alldf)
    all_out_data_df = pd.concat(all_out_data_df)

    return alldata, all_out_data_df


class smarts(object):
    name = "smarts"
    this_dir = os.path.split(__file__)[0]
    module_name = __name__
    plugin_module_name = "solcore3.plugins.smarts"
    working_directory = os.path.join(this_dir, "smarts_contents")
    executable = os.path.join(this_dir, "smarts_contents", "smarts295bat")
    ext_file = os.path.join(working_directory, "smarts295.ext.txt")
    inp_file = os.path.join(working_directory, "smarts295.inp.txt")
    out_file = os.path.join(working_directory, "smarts295.out.txt")
    scn_file = os.path.join(working_directory, "smarts295.scn.txt")


def skipper(fname):
    with open(fname) as fin:
        no_comments = (line for line in fin if "   " in line)
        next(no_comments, None)  # skip header
        next(no_comments, None)  # skip header
        for row in no_comments:
            yield row


def parse_smarts_out(file,to_df=True):
    """
    This function extracts the parameter in the xxxx.out.txt file generated by SMARTS.
    It returns a dictionary with {parameter key: parameter value} set.
    If to_df is True, it returns {parameter key: [parameter value]}
    so that it can be converted to pandas Dataframe.

    If a parameter or the input file is not found, it will return np.nan for each parameter.

    :param file: the xxxx.out.txt file generated by SMARTS
    :param to_df: True if the returned dictionary will be converted to pandas dataframe
    :return: A dictionary of {parameter key: parameter value}
    """
    result = {}
    zenith_pat = r"Zenith Angle \(apparent\) =\s+(?P<zenith>[0-9.]+)"
    azimuth_pat = r"Azimuth \(from North\) =\s+(?P<azimuth>[0-9.]+)"
    direct_tilt_pat=r"FOR THE TILTED PLANE:\s+Direct Beam =\s+(?P<direct_tilt>[0-9.]+)"
    direct_normal_pat=\
        r"DIRECT BEAM AT NORMAL INCIDENCE:\s+Extraterrestrial =\s+[0-9.]+\s+Terrestrial =\s+(?P<direct_normal>[0-9.]+)"
    pattern_map={zenith_pat:'zenith',
                 azimuth_pat:'azimuth',
                 direct_tilt_pat:'direct_tilt',
                 direct_normal_pat:'direct_normal'}

    if os.path.exists(file)==False:
        for pat in pattern_map:
            reg_key=pattern_map[pat]
            if to_df == True:
                result[reg_key] = [numpy.nan]
            else:
                result[reg_key] = numpy.nan
        return result


    with open(file, 'r') as fp:
        all_file = fp.read()

        for pat in pattern_map.keys():
            reg_key=pattern_map[pat]

            n = re.search(pat, all_file)

            if n is None:
                if to_df==True:
                    result[reg_key]=[numpy.nan]
                else:
                    result[reg_key]=numpy.nan
            else:
                if to_df==True:
                    result[reg_key] = [float(n.group(reg_key))]
                else:
                    result[reg_key] = float(n.group(reg_key))


    return result


def send_to_smarts(smarts_file_contents):
    subprocess.run(['rm', smarts.out_file])
    subprocess.run(['rm', smarts.scn_file])

    this_process = subprocess.Popen((smarts.executable,),
                                    stdout=subprocess.PIPE,
                                    stdin=subprocess.PIPE,
                                    stderr=subprocess.PIPE, cwd=smarts.working_directory)

    with open(smarts.inp_file, "w") as f:
        f.write(smarts_file_contents)

    if os.path.exists(smarts.ext_file):
        os.remove(smarts.ext_file)
    if os.path.exists(smarts.out_file):
        os.remove(smarts.out_file)
    if os.path.exists(smarts.scn_file):
        os.remove(smarts.scn_file)

    r = this_process.communicate(input=bytes("Y\n", "ASCII"))

    # print(r)

    # output_text = ""
    # if os.path.exists(smarts.scn_file):
    #     with open (smarts.out_file) as f:
    #         output_text = f.read()

    data = []
    if os.path.exists(smarts.scn_file):
        if os.stat(smarts.scn_file).st_size > 0:
            # read file header
            with open(smarts.scn_file) as fp:
                for i, line in enumerate(fp):
                    if i == 2:
                        headerline = line
            headerline = headerline.split()

            numdata = numpy.loadtxt(skipper(smarts.scn_file), unpack=False)
            # numdata=numpy.loadtxt(smarts.scn_file,skiprows=4,delimiter=" ")
            # data = pd.read_csv(smarts.scn_file,header=3,sep='\s+')

            data = pd.DataFrame(numdata, columns=headerline)


        else:
            data = None
    else:
        data = None


    out_file_data = parse_smarts_out(smarts.out_file)

    return data, out_file_data


def build_smarts_file(**kwargs):
    try:
        smarts_file_contents = ["'{COMNT}' !Card 1"]
        smarts_file_contents.append("{ISPR} !Card 2")
        smarts_file_contents.append([
                                        "{SPR} !Card 2a",
                                        "{SPR} {ALTIT} {HEIGHT} !Card 2a",
                                        "{LATIT} {ALTIT} {HEIGHT} !Card 2a"
                                    ][kwargs["ISPR"]])

        smarts_file_contents.append("{IATMOS} !Card 3")
        smarts_file_contents.append([
                                        "{TAIR} {RH} '{SEASON}' {TDAY} !Card 3a",
                                        "'{ATMOS}' !Card 3a"
                                    ][kwargs["IATMOS"]])

        smarts_file_contents.append("{IH2O} !Card 4")
        if kwargs["IH2O"] == 0:
            smarts_file_contents.append("{W} !Card 4a")

        smarts_file_contents.append("{IO3} !Card 5")
        if kwargs["IO3"] == 0:
            smarts_file_contents.append("{IALT} {AbO3} !Card 5a")

        smarts_file_contents.append("{IGAS} !Card 6")
        if kwargs["IGAS"] == 0:
            smarts_file_contents.append("{ILOAD} !Card 6a")
            if kwargs["ILOAD"] == 0:
                smarts_file_contents.append(
                    "{ApCH2O} {ApCH4} {ApCO} {ApHNO2} {ApHNO3} {ApNO} {ApNO2} {ApNO3} {ApO3} {ApSO2} !Card 6b"
                )

        smarts_file_contents.append("{qCO2} !Card 7")
        smarts_file_contents.append("{ISPCTR} !Card 7a")

        smarts_file_contents.append("'{AEROS}' !Card 8")
        if kwargs["AEROS"] == "USER":
            smarts_file_contents.append("{ALPHA1} {ALPHA2} {OMEGL} {GG} !Card 8a")

        smarts_file_contents.append("{ITURB} !Card 9")
        smarts_file_contents.append([
                                        "{TAU5} !Card 9a",
                                        "{BETA} !Card 9a",
                                        "{BCHUEP} !Card 9a",
                                        "{RANGE} !Card 9a",
                                        "{VISI} !Card 9a",
                                        "{TAU550} !Card 9a",
                                    ][kwargs["ITURB"]])

        smarts_file_contents.append("{IALBDX} !Card 10")
        if kwargs["IALBDX"] == -1:
            smarts_file_contents.append("{RHOX} !Card 10a")
        smarts_file_contents.append("{ITILT} !Card 10b")
        if kwargs["ITILT"] == 1:
            smarts_file_contents.append("{IALBDG} {TILT} {WAZIM} !Card 10c")
            if kwargs["IALBDG"] == 1:
                smarts_file_contents.append("{RHOG} !Card 10d")

        smarts_file_contents.append("{WLMN} {WLMX} {SUNCOR} {SOLARC} !Card 11")

        smarts_file_contents.append("{IPRT} !Card 12")
        if kwargs["IPRT"] >= 1:
            smarts_file_contents.append("{WPMN} {WPMX} {INTVL} !Card 12a")
            if kwargs["IPRT"] == 2 or kwargs["IPRT"] == 3:
                smarts_file_contents.append("{IOTOT} !Card 12b")
                smarts_file_contents.append("{IOUT} !Card 12c")

        smarts_file_contents.append("{ICIRC} !Card 13")
        if kwargs["ICIRC"] == 1:
            smarts_file_contents.append("{SLOPE} {APERT} {LIMIT} !Card 13a")

        smarts_file_contents.append("{ISCAN} !Card 14")
        if kwargs["ISCAN"] == 1:
            smarts_file_contents.append("{IFILT} {WV1} {WV2} {STEP} {FWHM} !Card 14a")

        smarts_file_contents.append("{ILLUM} !Card 15")

        smarts_file_contents.append("{IUV} !Card 16")

        smarts_file_contents.append("{IMASS} !Card 17")
        smarts_file_contents.append([
                                        "{ZENIT} {AZIM} !Card 17a",
                                        "{ELEV} {AZIM} !Card 17a",
                                        "{AMASS} !Card 17a",
                                        "{YEAR} {MONTH} {DAY} {HOUR} {LATIT} {LONGIT} {ZONE} !Card 17a",
                                        "{MONTH} {LATIT} {DSTEP} !Card 17a",
                                    ][kwargs["IMASS"]])

        smarts_file_schema = "\n".join(smarts_file_contents)
        # print (smarts_file_schema)
        smarts_file_complete = smarts_file_schema.format(**kwargs) + "\n"
    except KeyError:
        print("The SMARTS options you have selected require additional data, variables are undefined.")
        raise
    return smarts_file_complete


defaults = {
    "COMNT": "DEFAULT",
    "ISPR": 1,
    "SPR": 820.,
    "ALTIT": 1.829,
    "HEIGHT": 0.,
    "IATMOS": 1,
    "ATMOS": "MLS",
    "IH2O": 1,
    "IO3": 1,
    "IGAS": 0,
    "ILOAD": 2,
    "qCO2": 370.,
    "ISPCTR": 1,
    "AEROS": "S&F_RURAL",
    "ITURB": 0,
    "TAU5": 0.085,
    "IALBDX": 26,
    "ITILT": 0,
    "WLMN": 280,
    "WLMX": 4000,
    "SUNCOR": 1,
    "SOLARC": 1367,
    "IPRT": 0,
    "ICIRC": 1,
    "SLOPE": 0,
    "APERT": 3,
    "LIMIT": 0,
    "ISCAN": 1,
    "IFILT": 1,
    "WV1": 300,
    "WV2": 1100,
    "STEP": 2,
    "FWHM": 6.15,
    "ILLUM": 1,
    "IUV": 1,
    "IMASS": 0,
    "ZENIT": 67.51,
    "AZIM": 180.,
}

astmg_173_03 = {
    "COMNT": "USSA_AOD=0.084",
    "ISPR": 1,
    "SPR": 1013.25,
    "ALTIT": 0,
    "HEIGHT": 0.,
    "IATMOS": 1,
    "ATMOS": "USSA",
    "IH2O": 1,
    "IO3": 1,
    "IGAS": 1,
    "ILOAD": 2,
    "qCO2": 370.,
    "ISPCTR": 1,
    "AEROS": "S&F_RURAL",
    "ITURB": 0,
    "TAU5": 0.084,
    "IALBDX": 38,
    "ITILT": 1,
    "IALBDG": 38,
    "TILT": 37.,
    "WAZIM": 180.,
    "WLMN": 280,
    "WLMX": 4000,
    "SUNCOR": 1,
    "SOLARC": 1367,
    "IPRT": 0,
    "ICIRC": 1,
    "SLOPE": 0,
    "APERT": 2.9,
    "LIMIT": 0,
    "ISCAN": 0,
    "ILLUM": 0,
    "IUV": 0,
    "IMASS": 2,
    "AMASS": 1.5,
}

# This is identical to ASTMG173-03 shown in Example 6
# except that it added a filter ("ISCAN"=1) in the output
# Note that "WV2" cannot exceed 1900 or so.
astmg_173_03_m = {
    "COMNT": "DEFAULT",
    "ISPR": 1,
    "SPR": 1013.25,
    "ALTIT": 0.,
    "HEIGHT": 0.,
    "IATMOS": 1,
    "ATMOS": "USSA",
    "IH2O": 1,
    "IO3": 1,
    "IGAS": 1,
    "ILOAD": 2,
    "qCO2": 370.,
    "ISPCTR": 1,
    "AEROS": "S&F_RURAL",
    "ITURB": 0,
    "TAU5": 0.084,
    "IALBDX": 38,
    "ITILT": 1,
    "IALBDG": 38,
    "TILT": 37.,
    "WAZIM": 180.,
    "WLMN": 280,
    "WLMX": 2000,
    "SUNCOR": 1,
    "SOLARC": 1367,
    "IPRT": 0,
    "ICIRC": 1,
    "SLOPE": 0,
    "APERT": 2.9,
    "LIMIT": 0,
    "ISCAN": 1,
    "IFILT": 1,
    "WV1": 300,
    "WV2": 1900,
    "STEP": 2,
    "FWHM": 6.15,
    "ILLUM": 0,
    "IUV": 0,
    "IMASS": 2,
    "AMASS": 1.5,
    "ZENIT": 67.51,
    "AZIM": 180.,
}

if __name__ == "__main__":
    import matplotlib.pyplot as plt

    file = build_smarts_file(
        **astmg_173_03_m
    )

    print(file)

    data,_ = send_to_smarts(file)
    print(data)

    plt.plot(data['WVLGTH'], data['ET_SPCTRUM'], hold=True)
    plt.plot(data['WVLGTH'], data['BEAM_NORMAL'])
    # plt.show()


    result = parse_smarts_out("./smarts_contents/smarts295.out.txt",to_df=False)
    print(result)
